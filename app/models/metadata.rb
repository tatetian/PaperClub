class Metadata < ActiveRecord::Base
  attr_accessible :num_pages, :pub_date, :title, :uuid, :width, :height

  after_destroy :remove_files

  # Call pdf2htmlEX for the PDF again ASYNCHRONOUSLY
  def redo_pdf2html
    dest_dir = Rails.root.join("uploads", uuid)
    pdf_path = Rails.root.join("uploads", uuid, "fulltext.pdf")
    Metadata.delay.pdf2htmlEX(pdf_path, dest_dir)
  end

  # Get the number of papers of this metadata
  def paper_count
    Paper.where(:uuid => self.uuid).count
  end

  def used?
    Paper.exists?(:uuid => self.uuid) 
  end

  def remove_files
    dir = self.get_dir
    begin
      FileUtils.rm_rf dir
    rescue
    end
  end

  def get_dir
    Rails.root.join("public", "uploads", self.uuid) 
  end

  # Calculate the UUID of a file given its file path
  #   UUID which is encoded in Base64 is generated by truncating SHA-1 hash
  def self.calculate_uuid(file_path)
    # Use SHA-1 to calculate a hash for the file
    # e.g. "74e10ff37b568e76c5166ce8b0eddf2abfdcbac9"
    require 'digest/sha1'
    sha1 = Digest::SHA1.hexdigest(File.read(file_path)).to_s
    # Convert SHA-1 value to UUID
    # e.g. "dOEP83tWjnbFFmzosO3fKg"
    Metadata.sha1_to_uuid sha1
  end

  def self.sha1_to_uuid(sha1) 
    # Truncate SHA-1 to UUID
    #   SHA-1 is 160-bit, UUID is 128-bit
    #   So we want the first 32 HEX digits (128/4=32)
    #   Although this uuid is same as version 5 UUID in essence, 
    #   they are not equal.
    # e.g. "74e10ff37b568e76c5166ce8b0eddf2a"
    shorter = sha1[0...32]
    # Get bytes representation of uuid
    # e.g. "t\xE1\x0F\xF3{V\x8Ev\xC5\x16l\xE8\xB0\xED\xDF*"
    bytes = [shorter].pack("H*")
    # Encode the bytes of uuid in Base64 encoding for shorter representation
    # A-Z, a-z, 0-9, -, _
    # e.g. "dOEP83tWjnbFFmzosO3fKg=="
    require "base64"
    base64 = Base64.urlsafe_encode64(bytes)
    # Discard the trailing '==' 
    #   In base 64 encoding, the trailing '=' is padding
    #     '==' indicates that the last group contains only 1 bytes
    #     '=' indicates that the last group contains 2 bytes
    # e.g. "dOEP83tWjnbFFmzosO3fKg"
    res = base64[0...-2]
    # Replace "-" with "+" because "-" has special meaning in shell command
    res.gsub!('-', '+')

    res
  end

  def self.find_or_create_from pdf_path, options={}
    options.reverse_merge! :force_create => false

    # Metadata
    uuid = Metadata.calculate_uuid pdf_path
    metadata = Metadata.find_by_uuid(uuid)

    # Sometimes we want to regenerate the metadata
    if options[:force_create] and metadata
      metadata.destroy
      metadata = nil
    end

    # If metadata doesn't exist, create it
    if not metadata
      # Extract metadata from PDF
      metadata = Metadata.create_from(
                    pdf_path, uuid, options)
    end

    metadata 
  end

  def self.create_from pdf_path, uuid, options={}
    options.reverse_merge! :default_title => "Untitled",
                           :preserve_src  => false

    pdf_path = File.absolute_path(pdf_path)

    # Extract metadata from PDF 
    json_meta = %x[pdf2htmlEX --only-meta 1 "#{pdf_path}"] 
    parsed_meta = ActiveSupport::JSON.decode json_meta

    title = parsed_meta["title"]
    # Too short
    if title.mb_chars.length < 5
      #title = 
      title = options[:default_title]
    end
    # Too long
    if title.mb_chars.length > 100
      title = title.slice(0,100) + "..."
    end
    # Empty date
    pub_date = parsed_meta["modified_date"]
    if pub_date.empty?
      pub_date = nil
    end

    metadata = Metadata.create( title: title,
                                pub_date: pub_date,
                                num_pages: parsed_meta["num_pages"],
                                width: parsed_meta["width"],  
                                height: parsed_meta["height"],
                                uuid: uuid )

    # Prepare the dest dir
    dest_dir = Rails.root.join("uploads", uuid)
    unless File.directory?(dest_dir)
      Dir.mkdir dest_dir
    end

    # Move the PDF to permanent place if needed
    dest_pdf_path = Rails.root.join("uploads", uuid, "fulltext.pdf")
    unless pdf_path == dest_pdf_path
      if options[:preserve_src]
        FileUtils.cp(pdf_path, dest_pdf_path)
      else
        FileUtils.mv(pdf_path, dest_pdf_path)
      end
    end
    # Convert the file from PDF to HTML5 ASYNCHRONOUSLY
    Metadata.delay.pdf2htmlEX(dest_pdf_path, dest_dir)

    metadata
  end

  def self.pdf2htmlEX(pdf_path, dest_dir)
    tmp_dir = "/tmp/paperclub-" + $$.to_s + "-" + Time.now.to_i.to_s
    # PDF -> HTML5
    %x[pdf2htmlEX --embed-base-font 0 --tmp-dir "#{tmp_dir}" --dest-dir "#{dest_dir.to_s}" "#{pdf_path.to_s}"]
  end
end
