class Paper < ActiveRecord::Base
  attr_accessible :uuid, :pub_date, :title, :num_pages,
                  :width, :height,
                  :club_id, :uploader_id

  belongs_to :club

  has_many :collections, foreign_key: "paper_id"
  has_many :tags, through: :collections

  has_many :notes

  validate :title, presence: true
  validate :club_id, presence: true

  default_scope :order => 'papers.updated_at DESC'

  # Remove the associated metadata if no paper uses it
  after_destroy { |paper|
    metadata = Metadata.find_by_uuid(paper.uuid)
    if metadata and not metadata.used?
      metadata.destroy
    end
  }

  # Search papers in a club given keywords, tag and uploader
  def self.search(club_id, params) 
    conditions = ["papers.club_id=#{club_id}"]
    conditions << "papers.title LIKE ('%#{params[:keywords]}%')" if params[:keywords]
    conditions << "papers.uploader_id=#{params[:user_id]}" if params[:user_id]
    if(params[:tag_id])
      where << "collections.tag_id=#{params[:tag_id]}"
      return Paper.joins(:collections).where(conditions.join(" AND "))
    else
      return Paper.where(conditions.join(" AND "))
    end
  end

  # Get who uploaded the paper
  def uploader
    User.find(self.uploader_id)
  end

  # Set who uploaded the paper
  def uploader=(user_id)
    self.uploader_id = user_id
  end

  def as_json(options)
    {
      id:       self.id,
      title:    self.title, 
      pub_date: self.pub_date,
      num_pages: self.num_pages,
      width:    self.width,
      height:   self.height,
      tags:     self.tags.map { |t|
                  t.as_json(options)
                },
      uploader_id:  self.uploader_id,
      news:     nil,
      created_at: self.created_at,
      updated_at: self.updated_at
    }
  end

  # Calculate the UUID of a file given its file path
  #   UUID which is encoded in Base64 is generated by truncating SHA-1 hash
  def self.calculate_uuid(f)
    # Use SHA-1 to calculate a hash for the file
    # e.g. "74e10ff37b568e76c5166ce8b0eddf2abfdcbac9"
    require 'digest/sha1'
    sha1 = Digest::SHA1.hexdigest(File.read(f)).to_s
    # Convert SHA-1 value to UUID
    # e.g. "dOEP83tWjnbFFmzosO3fKg"
    Paper.sha1_to_uuid sha1
  end

  def self.sha1_to_uuid(sha1) 
    # Truncate SHA-1 to UUID
    #   SHA-1 is 160-bit, UUID is 128-bit
    #   So we want the first 32 HEX digits (128/4=32)
    #   Although this uuid is same as version 5 UUID in essence, 
    #   they are not equal.
    # e.g. "74e10ff37b568e76c5166ce8b0eddf2a"
    shorter = sha1[0...32]
    # Get bytes representation of uuid
    # e.g. "t\xE1\x0F\xF3{V\x8Ev\xC5\x16l\xE8\xB0\xED\xDF*"
    bytes = [shorter].pack("H*")
    # Encode the bytes of uuid in Base64 encoding for shorter representation
    # e.g. "dOEP83tWjnbFFmzosO3fKg=="
    require "base64"
    base64 = Base64.urlsafe_encode64(bytes)
    # Discard the trailing '==' 
    #   In base 64 encoding, the trailing '=' is padding
    #     '==' indicates that the last group contains only 1 bytes
    #     '=' indicates that the last group contains 2 bytes
    # e.g. "dOEP83tWjnbFFmzosO3fKg"
    res = base64[0...-2]
  end
end
